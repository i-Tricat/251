# `ship_25.py` 코드 리뷰 보고서

## 1. 종합 평가

현재 `ship_25.py` 코드는 선박의 자율 운항을 위한 장애물 회피, 웨이포인트 추종, 도킹 등 핵심 기능의 프로토타입을 구현하고 있습니다. 하지만 단일 파일에 너무 많은 기능이 집중되어 있어 여러 심각한 문제를 내포하고 있습니다. 이로 인해 코드의 안정성, 성능, 확장성, 유지보수성이 크게 저하된 상태입니다.

장기적인 관점에서 안정적이고 신뢰성 있는 소프트웨어로 발전하기 위해서는 **전면적인 구조 리팩토링이 반드시 필요**합니다. 가장 시급한 과제는 기능별로 노드를 분리하여 각 노드가 단일 책임 원칙을 따르도록 하는 것입니다.

## 2. 문제점 및 개선 방안 (우선순위 순)

### P0: 치명적인 오류 및 버그

#### 1.1. 초기화되지 않은 웨이포인트 접근
- **문제 위치:** [`main()`](src/tricat/tricat_251/src/ship_25.py:732) 루프, [`ship_run()`](src/tricat/tricat_251/src/ship_25.py:156)
- **문제점:** 웨이포인트가 부족할 경우(`len(WP_k) < 2`)에도 `WP_k[1]`에 접근하여 `IndexError`를 발생시키고 노드를 충돌시킵니다.
- **영향:** **제어 불능 상태**로 이어질 수 있는 치명적인 오류입니다.
- **수정 제안:** `WP_k` 리스트의 길이를 먼저 확인하고, 2 미만일 경우 제어 로직을 건너뛰도록 `continue` 처리를 강화해야 합니다.

#### 1.2. `docking_process` 내 블로킹(Blocking) 호출
- **문제 위치:** [`docking_process()`](src/tricat/tricat_251/src/ship_25.py:601) 내 `while time.time() ...` 루프
- **문제점:** `time.sleep()`을 포함한 동기식 `while` 루프가 메인 제어 루프를 차단하여, 해당 시간 동안 센서 데이터(위치, 장애물)가 전혀 갱신되지 않습니다.
- **영향:** **'눈을 감고' 항해**하는 것과 같아 충돌 및 경로 이탈의 위험이 매우 큽니다.
- **수정 제안:** 해당 로직을 상태 머신 패턴과 ROS 시간을 이용한 비동기 방식으로 변경해야 합니다. (자세한 내용은 아키텍처 섹션 참조)

#### 1.3. GUI 환경 의존성
- **문제 위치:** [`docking_process()`](src/tricat/tricat_251/src/ship_25.py:601) 내 `cv2.imshow`, `cv2.waitKey`
- **문제점:** GUI가 없는 환경(예: SSH 터미널)에서 노드를 실행할 경우, `cv2` 관련 함수가 오류를 일으키며 **노드를 충돌**시킵니다.
- **영향:** 배포 환경에 따라 프로그램 실행 자체가 불가능해집니다.
- **수정 제안:** ROS 파라미터를 이용해 디버깅용 시각화 기능을 켜고 끌 수 있도록 분리해야 합니다.

### P1: 성능 병목 현상

#### 2.1. 제어와 인식이 결합된 구조
- **문제점:** CPU 집약적인 이미지 처리(`docking_process`)가 10Hz로 실행되어야 하는 제어 루프 내에 포함되어 있습니다.
- **영향:** 이미지 처리 시간에 따라 제어 주기가 불안정해지고, 선박의 반응성이 저하됩니다.
- **수정 제안:** 이미지 처리를 전담하는 **별도의 ROS 노드로 분리**하는 아키텍처 변경이 시급합니다. (자세한 내용은 아키텍처 섹션 참조)

#### 2.2. 불필요한 중복 계산
- **문제점:** 장애물 회피 벡터를 계산하는 함수(`delete_vector_inside_obstacle` 등)가 여러 곳에서 중복으로 호출됩니다.
- **영향:** 장애물이 많아질수록 계산량이 증가하여 성능을 저하 시킵니다.
- **수정 제안:** 함수 간 데이터 흐름을 명확히 하여, 한 번 계산된 결과는 인자로 전달하여 재사용해야 합니다.

### P2: 코드 가독성 및 유지보수성 (코드 스멜)

#### 3.1. 클래스 속성 남용 (전역 변수화)
- **문제점:** 대부분의 변수가 `self` 속성으로 선언되어, 여러 함수에서 명시적인 전달 없이 수정되고 있습니다. 이는 데이터 흐름을 파악하기 매우 어렵게 만듭니다.
- **영향:** 잠재적인 버그의 온상이 되며, 코드 수정 및 디버깅을 극도로 어렵게 만듭니다.
- **수정 제안:** '상태'를 나타내는 최소한의 정보만 `self`에 저장하고, 함수 간의 데이터는 **인자와 반환 값을 통해 명시적으로 전달**하도록 리팩토링해야 합니다.

#### 3.2. 매직 넘버(Magic Numbers) 과다 사용
- **문제점:** `1500`, `150`, `1600` 등 의미를 알 수 없는 숫자 상수가 코드 전반에 하드코딩되어 있습니다.
- **영향:** 가독성을 해치고, 파라미터 튜닝 시 실수를 유발하기 쉽습니다.
- **수정 제안:** 모든 상수를 `__init__`에 **의미 있는 이름의 변수로 정의**하고, 가급적 **ROS 파라미터 서버**를 통해 외부에서 설정할 수 있도록 변경해야 합니다.

#### 3.3. 일관성 없는 네이밍 및 단위 사용
- **문제점:** 라디안(rad)과 도(degree) 단위가 혼용되고 있으며, `WP_k`, `ch` 등 의미가 불분명한 변수명이 사용됩니다.
- **영향:** 계산 오류를 유발하고 코드 이해를 방해합니다.
- **수정 제안:** 변수명에 `_rad`, `_deg` 등 **단위를 명시**하고, 역할을 명확히 설명하는 이름을 사용해야 합니다. (PEP 8 준수)

### P3: 아키텍처 및 모범 사례

#### 4.1. 단일 노드의 과도한 책임 (Monolithic Node)
- **문제점:** 현재의 단일 노드 구조는 ROS의 장점을 전혀 활용하지 못하고 있습니다.
- **영향:** 확장성, 테스트 용이성, 안정성이 모두 떨어집니다.
- **개선 방안:** **기능별로 노드를 분리**하는 것이 가장 근본적인 해결책입니다.
    - **인식 노드:** `obstacle_detector`, `docking_marker_detector`
    - **경로 계획 노드:** `path_planner`
    - **제어 노드:** `ship_controller`
    - **상태 관리 노드:** `waypoint_manager`

#### 4.2. 테스트 용이성 부재
- **문제점:** 모든 로직이 ROS와 강하게 결합되어 있어 단위 테스트(Unit Test)가 불가능합니다.
- **영향:** 개발 및 버그 수정 속도를 크게 저하시킵니다.
- **개선 방안:** 핵심 계산 로직은 **ROS에 의존하지 않는 순수 Python 모듈로 분리**하고, ROS 노드는 이 모듈을 사용하는 래퍼(Wrapper) 역할만 하도록 구조를 변경하여 테스트 용이성을 확보해야 합니다.

## 3. 권장 리팩토링 절차

1.  **[1단계] 즉시 수정:** `IndexError` 방지, `cv2` 코드 분기 처리 등 당장 노드를 안정화시키는 작업을 수행합니다.
2.  **[2단계] 제어/인식 분리:** 이미지 처리 부분을 별도의 `docking_camera_node`로 분리합니다. (가장 큰 성능 및 구조 개선 효과)
3.  **[3단계] 데이터 흐름 명확화:** `ship_25.py` 내부에서 함수 간 인자와 반환 값을 사용하도록 리팩토링하고, 매직 넘버를 상수로 정리합니다.
4.  **[4단계] 전체 노드 분리:** 장기적인 관점에서 경로 계획, 제어 로직을 별도의 노드로 완전히 분리하는 작업을 진행합니다.

이 보고서가 코드의 품질을 향상시키는 데 도움이 되기를 바랍니다.